学习笔记

## TRIE 字典树

将字符串每一个字符当成Object树的key，对应一个Object由后续子串组成。
最后用$表示字符串末尾，并用于存储字符串重复的数量。

- 1. insert: 将字符串插入字典树
- 2. most: 求出重复次数最多的字符串，和其重复的数量

## KMP

- 1. 寻找重复子串：遍历pattern字符串，用table存储对应每一个字符前面已经重复的字符数量。 
  由于 重复子串字符数量 === 重复子串后下一位待匹配字符在字符串中的位置
  eg: 子串字符下标从0开始，已经有前n个字符匹配之后，下一位待匹配字符则处于0+n的位置。
  所以当遇到下一位字符不匹配的情况，可以用于跳转到之前已匹配的子串后一位，减少不必要的重复遍历。
  因此table中的每一个位置应该存储pattern对应位置字符前面已匹配字符的数量。

- 2. 字符串匹配：遍历待匹配的source字符串，遇到不能匹配的字符则从table中获取回溯的位置，之后从该位置继续匹配，直到匹配完整个source后返回结果。


## Wildcard

处理两个特殊字符：
'?' 当作任意字符，在正则里等同于 /s 和 /S 的合集。
'*' 等同于0～n次重复其前面的字符，对于多个星号，除最后一个星号外要匹配尽可能多的字符外，前面的星号均匹配尽可能少的字符。

故，由*将pattern划分成多段，前后段除？外字符完全匹配，中间段只要source中相应段的字符中存在该段pattern对应的内容，即算匹配成功。

- 1. 计算pattern存在的*个数，即将pattern根据星号分段。
- 2. 如果没有*则除？代表任意字符以外其余字符完全匹配返回结果。有则往下执行。
- 3. 前段除？代表任意字符以外其余字符完全匹配。
- 4. 中间由*开头的部分，生成子pattern串，由lastIndex划分source分段，逐段判断source是否匹配。
- 5. 后段除？代表任意字符以外其余字符完全匹配。
- 6. 如果2或3&4&5匹配则返回true，否则返回false。